---
title: 'Tarea reproducibilidad y disease mapping'
toc-title: "Contenido"
author: 'Autor: Santiago Moncalero, Diego Fernández y Jorge Guitart'
date: 'Fecha límite entrega: 9 de Diciembre 2024'
output:
  bookdown::word_document2:
    reference_docx: template.docx
    toc: true
  pdf_document:
    toc: true
subtitle: "2024-25 Especialización Gr.PT-I (42231). Máster de Bioestadística"
lang: es-ES
---

```{r include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.height=3.5)
```


# Introducción

Este análisis se centra en la estimación del Riesgo Relativo Modificado (RME) de la mortalidad en Aragón utilizando modelos espaciales, con el fin de identificar patrones y áreas con una mayor probabilidad de riesgo. El modelo se construye utilizando WinBUGS, un software diseñado para realizar inferencia bayesiana, particularmente en modelos complejos que implican dependencias espaciales.

El objetivo principal es modelar la mortalidad observada en cada municipio de Aragón, teniendo en cuenta la exposición a factores de riesgo y la heterogeneidad espacial en los datos. Para ello, empleamos una distribución Poisson para modelar las tasas de mortalidad, y un modelo CAR (Conditional Autoregressive) para capturar la dependencia espacial entre municipios vecinos. Esto permite un análisis más robusto y preciso de la mortalidad, considerando no solo los efectos directos de los factores de riesgo, sino también la influencia espacial.

Para optimizar el tiempo de cómputo, se utiliza un enfoque donde los resultados previamente generados se cargan directamente en lugar de recalcular todo el modelo, garantizando así una ejecución más eficiente y la posibilidad de replicar el análisis con los mismos resultados. Esta estrategia asegura la reproducibilidad del estudio, permitiendo que otros investigadores validen los resultados sin la necesidad de repetir costosos cálculos.

En esta sección, detallaremos el flujo de trabajo del modelo, la preparación de los datos, y los pasos seguidos para obtener los resultados y realizar su visualización, así como cómo se asegura que el análisis sea reproducible y accesible para otros estudios.


## Preparación del entorno

```{r setup, message=FALSE, warning=FALSE}
# Cargar librerías y datos
library(pacman)
pacman::p_load(sf, spdep, sp, R2WinBUGS, ggplot2, patchwork, Matrix, INLA)

# Cargar datos
load("./material/Aragon.Rdata")
aragon.sf <- st_read("./material/aragon.shp")

# Preprocesar datos
aragon.sf <- aragon.sf[order(aragon.sf$CODMUNI), ] # Ordenar por código municipal
aragon.sf <- cbind(aragon.sf, Aragon.df[, 2:3])   # Fusionar datos
rm(Aragon.df) # Eliminar objeto original
aragon.spdf <- as(aragon.sf, "Spatial") # Convertir a SpatialPolygonsDataFrame
vecinos <- nb2WB(poly2nb(aragon.spdf))  # Calcular vecinos para análisis espacial

# Crear matriz de adyacencia dispersa
row_indices <- rep(1:length(vecinos$num), times = vecinos$num)  # Filas
col_indices <- vecinos$adj  # Columnas
weights <- vecinos$weights  # Pesos
adj.matrix <- sparseMatrix(i = row_indices, j = col_indices, x = weights)
```


# Análisis con WinBUGS


```{r Este_codigo_se_ve_pero_no_se_ejecuta,echo=TRUE, eval=FALSE}
# Programamos el modelo
mod1 <- function() {
  for (i in 1:nObs) {
    O[i] ~ dpois(mu[i])
    log(mu[i]) <- log(E[i]) + m + het[i] + sp[i]
    het[i] ~ dnorm(0, prechet)
    R[i] <- exp(m + het[i] + sp[i])
  }
  
  sp[1:nObs] ~ car.normal(adj[], w[], num[], precsp)
  m ~ dflat()
  prechet <- pow(sdhet, -2); precsp <- pow(sdsp, -2)
  sdhet ~ dunif(0, 10); sdsp ~ dunif(0, 10)
  
  for (j in 1:nObs) {
    p.R[j] <- step(R[j] - 1) # Calcula la probabilidad de que RME sea mayor que 1
  }
}

# Ajustamos las distribuciones previas
inits.mod1 <- function() {list(m = rnorm(1), 
                               sdhet = runif(1), 
                               sdsp = runif(1))}

# Cargamos los datos
datos.mod1 <- list(O = aragon.spdf$O, 
                   E = aragon.spdf$E, 
                   adj = vecinos$adj, 
                   num = vecinos$num, 
                   w = vecinos$weights, 
                   nObs = length(aragon.spdf))

# Pedimos los resultados
params.mod1 <- c("R", "p.R")

# Lanzamos el modelo
res.mod1 <- bugs(data = datos.mod1, model = mod1,
                 param = params.mod1, inits = inits.mod1)
```



```{r include=FALSE}
### Este codigo no se ve porque es la carga
# Cargar resultados precomputados
load("./material/resmod1")

```



```{r}

# Añadir resultados al sf para visualización
aragon.sf$RME <- res.mod1$mean$R
aragon.sf$p.RME <- res.mod1$mean$p.R

# Graficar resultados de WinBUGS
rme.plot <- ggplot(aragon.sf) +
  geom_sf(aes(fill = RME)) +
  scale_fill_viridis_c(option = "plasma") +
  ggtitle("WinBUGS: RME") +
  theme_classic()

p.rme.plot <- ggplot(aragon.sf) +
  geom_sf(aes(fill = p.RME)) +
  scale_fill_viridis_c(option = "viridis") +
  ggtitle("WinBUGS: P(RME > 1)") +
  labs(fill = "P(RME > 1)") +
  theme_classic()


```

